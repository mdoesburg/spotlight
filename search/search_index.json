{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Spotlight \u00b6 Data validation for Python, inspired by the Laravel framework. Requirements \u00b6 Python 3.6+ Installation \u00b6 Spotlight can be installed via pip: pip install spotlight Example \u00b6 To validate data, we start by defining validation rules for each field we want to validate. After that, we pass the data and the validation rules into the Validator's validate method. Lets have a look at a simple example: from spotlight import Validator rules = { \"id\" : \"required|integer\" , \"email\" : \"required|email\" , \"first_name\" : \"required|string\" , \"last_name\" : \"required|string\" , \"password\" : \"required|min:8|max:255\" , } data = { \"id\" : 1 , \"email\" : \"john.doe@example.com\" , \"first_name\" : \"John\" , \"last_name\" : \"Doe\" , \"password\" : \"test\" , } validator = Validator () errors = validator . validate ( data , rules ) The validate method will return a dictionary of errors, if any occurred. In the example above, the validate method will return the following errors: { \"password\" : [ \"The password field has to be at least 8 characters.\" ]} Alternatively, validation rules may be specified as lists of rules instead of a single | delimited string: rules = { \"id\" : [ \"required\" , \"integer\" ], \"email\" : [ \"required\" , \"email\" ], \"first_name\" : [ \"required\" , \"string\" ], \"last_name\" : [ \"required\" , \"string\" ], \"password\" : [ \"required\" , \"min:8\" , \"max:255\" ], }","title":"Overview"},{"location":"#spotlight","text":"Data validation for Python, inspired by the Laravel framework.","title":"Spotlight"},{"location":"#requirements","text":"Python 3.6+","title":"Requirements"},{"location":"#installation","text":"Spotlight can be installed via pip: pip install spotlight","title":"Installation"},{"location":"#example","text":"To validate data, we start by defining validation rules for each field we want to validate. After that, we pass the data and the validation rules into the Validator's validate method. Lets have a look at a simple example: from spotlight import Validator rules = { \"id\" : \"required|integer\" , \"email\" : \"required|email\" , \"first_name\" : \"required|string\" , \"last_name\" : \"required|string\" , \"password\" : \"required|min:8|max:255\" , } data = { \"id\" : 1 , \"email\" : \"john.doe@example.com\" , \"first_name\" : \"John\" , \"last_name\" : \"Doe\" , \"password\" : \"test\" , } validator = Validator () errors = validator . validate ( data , rules ) The validate method will return a dictionary of errors, if any occurred. In the example above, the validate method will return the following errors: { \"password\" : [ \"The password field has to be at least 8 characters.\" ]} Alternatively, validation rules may be specified as lists of rules instead of a single | delimited string: rules = { \"id\" : [ \"required\" , \"integer\" ], \"email\" : [ \"required\" , \"email\" ], \"first_name\" : [ \"required\" , \"string\" ], \"last_name\" : [ \"required\" , \"string\" ], \"password\" : [ \"required\" , \"min:8\" , \"max:255\" ], }","title":"Example"},{"location":"plugins/","text":"Plugins \u00b6 Spotlight SQLAlchemy \u00b6 To use database rules such as unique and exists checkout the Spotlight SQLAlchemy plugin.","title":"Plugins"},{"location":"plugins/#plugins","text":"","title":"Plugins"},{"location":"plugins/#spotlight-sqlalchemy","text":"To use database rules such as unique and exists checkout the Spotlight SQLAlchemy plugin.","title":"Spotlight SQLAlchemy"},{"location":"release_notes/","text":"Release Notes \u00b6 3.3.0 \u00b6 Features \u00b6 Add prohibited_if rule Add prohibited_unless rule Add prohibited_with rule 3.2.0 \u00b6 Features \u00b6 Add support for defining a rule with parameters as a tuple or a list Add prohibited rule 3.1.0 \u00b6 Features \u00b6 Add implicit and stop flag support to function rules. 3.0.1 \u00b6 Fixes \u00b6 The after , after_or_equal , before , and before_or_equal rules no longer raise a date time error when the dependent field/value is missing or incorrect. 3.0.0 \u00b6 Breaking Changes \u00b6 Add support for date objects. Python date objects will now pass date_time validation and can be used in all date rules. 2.3.3 \u00b6 Fixes \u00b6 Fix rule split bug when using date rules in combination with list notation 2.3.2 \u00b6 Fixes \u00b6 Exclude regex rule from param split. This fixes the regex rule for regular expressions that contain commas. 2.3.1 \u00b6 Fixes \u00b6 Fix nested field lookup when determining date and format 2.3.0 \u00b6 Features \u00b6 Add after_or_equal rule Add before_or_equal rule 2.2.1 \u00b6 Fixes \u00b6 Nested values now get resolved properly for the required_if and required_unless rule 2.2.0 \u00b6 Features \u00b6 Add support for better imports. For example, you can now do from spotlight import Validator instead of from spotlight.validator import Validator . Internal \u00b6 Increase test coverage to 100% 2.1.0 \u00b6 Features \u00b6 Add support for custom validation functions 2.0.1 \u00b6 Fixes \u00b6 Add missing empty checks to the required_if , required_unless , required_with , and required_without rules. These rules were only checking if a field was present instead of also checking if the value was empty or not. 2.0.0 \u00b6 Breaking Changes \u00b6 True and False are now considered valid integers, because bool is an instance of int in Python. 1.1.0 \u00b6 Features \u00b6 Add regex rule Add decimal support to size rule","title":"Release Notes"},{"location":"release_notes/#release-notes","text":"","title":"Release Notes"},{"location":"release_notes/#330","text":"","title":"3.3.0"},{"location":"release_notes/#features","text":"Add prohibited_if rule Add prohibited_unless rule Add prohibited_with rule","title":"Features"},{"location":"release_notes/#320","text":"","title":"3.2.0"},{"location":"release_notes/#features_1","text":"Add support for defining a rule with parameters as a tuple or a list Add prohibited rule","title":"Features"},{"location":"release_notes/#310","text":"","title":"3.1.0"},{"location":"release_notes/#features_2","text":"Add implicit and stop flag support to function rules.","title":"Features"},{"location":"release_notes/#301","text":"","title":"3.0.1"},{"location":"release_notes/#fixes","text":"The after , after_or_equal , before , and before_or_equal rules no longer raise a date time error when the dependent field/value is missing or incorrect.","title":"Fixes"},{"location":"release_notes/#300","text":"","title":"3.0.0"},{"location":"release_notes/#breaking-changes","text":"Add support for date objects. Python date objects will now pass date_time validation and can be used in all date rules.","title":"Breaking Changes"},{"location":"release_notes/#233","text":"","title":"2.3.3"},{"location":"release_notes/#fixes_1","text":"Fix rule split bug when using date rules in combination with list notation","title":"Fixes"},{"location":"release_notes/#232","text":"","title":"2.3.2"},{"location":"release_notes/#fixes_2","text":"Exclude regex rule from param split. This fixes the regex rule for regular expressions that contain commas.","title":"Fixes"},{"location":"release_notes/#231","text":"","title":"2.3.1"},{"location":"release_notes/#fixes_3","text":"Fix nested field lookup when determining date and format","title":"Fixes"},{"location":"release_notes/#230","text":"","title":"2.3.0"},{"location":"release_notes/#features_3","text":"Add after_or_equal rule Add before_or_equal rule","title":"Features"},{"location":"release_notes/#221","text":"","title":"2.2.1"},{"location":"release_notes/#fixes_4","text":"Nested values now get resolved properly for the required_if and required_unless rule","title":"Fixes"},{"location":"release_notes/#220","text":"","title":"2.2.0"},{"location":"release_notes/#features_4","text":"Add support for better imports. For example, you can now do from spotlight import Validator instead of from spotlight.validator import Validator .","title":"Features"},{"location":"release_notes/#internal","text":"Increase test coverage to 100%","title":"Internal"},{"location":"release_notes/#210","text":"","title":"2.1.0"},{"location":"release_notes/#features_5","text":"Add support for custom validation functions","title":"Features"},{"location":"release_notes/#201","text":"","title":"2.0.1"},{"location":"release_notes/#fixes_5","text":"Add missing empty checks to the required_if , required_unless , required_with , and required_without rules. These rules were only checking if a field was present instead of also checking if the value was empty or not.","title":"Fixes"},{"location":"release_notes/#200","text":"","title":"2.0.0"},{"location":"release_notes/#breaking-changes_1","text":"True and False are now considered valid integers, because bool is an instance of int in Python.","title":"Breaking Changes"},{"location":"release_notes/#110","text":"","title":"1.1.0"},{"location":"release_notes/#features_6","text":"Add regex rule Add decimal support to size rule","title":"Features"},{"location":"usage/available_rules/","text":"Available Rules \u00b6 accepted \u00b6 The field under validation must be yes, on, 1, or true. This is useful for validating \"Terms of Service\" acceptance. accepted after \u00b6 The field under validation must be a value after a given date/time. For more details about formatting see the date_time rule. after:2019-12-31 12:00:00 If the after rule is accompanied by the date_time rule, and a non default format is specified, the specified format will be assumed for the after rule as well: date_time:%H:%M:%S|after:12:00:00 Instead of passing a date/time string to be evaluated by the strptime Python function, you may specify another field to compare against the date/time: after:some_field after_or_equal \u00b6 The field under validation must be a value after or equal to a given date/time. For more information, see the after rule. alpha_num \u00b6 The field under validation must be entirely alpha-numeric characters. alpha_num alpha_num_space \u00b6 The field under validation may have alpha-numeric characters, as well as spaces. alpha_num_space before \u00b6 The field under validation must be a value before a given date/time. For more details about formatting see the date_time rule. before:2019-12-31 12:00:00 If the before rule is accompanied by the date_time rule, and a non default format is specified, the specified format will be assumed for the before rule as well: date_time:%H:%M:%S|before:12:00:00 Instead of passing a date/time string to be evaluated by the strptime Python function, you may specify another field to compare against the date/time: before:some_field before_or_equal \u00b6 The field under validation must be a value before or equal to a given date/time. For more information, see the before rule. boolean \u00b6 The field under validation must be a boolean. boolean date_time \u00b6 The field under validation must be a valid date/time matching the \"YYYY-MM-DD hh:mm:ss\" format, or a custom specified format. For example, a field being validated with the following format \"date_time:%m/%d/%Y\" must match the \"MM/DD/YYYY\" format. The date/time validation uses the strptime Python function. For more info on valid formatting symbols check the following Python docs . date_time date_time:format decimal \u00b6 The field under validation must be a decimal. decimal dict \u00b6 The field under validation must be a dict. dict email \u00b6 The field under validation must be a valid email address. email ends_with \u00b6 The field under validation must end with one of the given values. ends_with:value,other,... filled \u00b6 The field under validation must not be empty when it is present. filled float \u00b6 The field under validation must be a float. float in \u00b6 The field under validation must be included in the given list of values. in:value,other,... integer \u00b6 The field under validation must be an integer. integer Note: Since version 2.0, True and False are considered valid integers, because bool is an instance of int in Python. ip \u00b6 The field under validation must be an IP address. ip json \u00b6 The field under validation must be a valid JSON string. json list \u00b6 The field under validation must be a list. list max \u00b6 The field under validation must be less than or equal to the given maximum value. For strings, value corresponds to the number of characters. For integers, value corresponds to a given integer value. For floats, value corresponds to a given float value. For decimals, value corresponds to a given decimal value. For lists and dicts, value corresponds to the length of the list/dict. max:value min \u00b6 The field under validation must be greater than or equal to the given minimum value. For strings, value corresponds to the number of characters. For integers, value corresponds to a given integer value. For floats, value corresponds to a given float value. For decimals, value corresponds to a given decimal value. For lists and dicts, value corresponds to the length of the list/dict. min:value not_with \u00b6 The field under validation can't be present if the other specified field is present. not_with:other prohibited \u00b6 The field under validation must be missing or empty. A field is considered \"empty\" if one of the following conditions are true: The value is None . The value is an empty string. The value is an empty list. The value is an empty dict. prohibited prohibited_if \u00b6 The field under validation must be missing or empty if the other specified field equals a certain value. prohibited_if:other,value prohibited_unless \u00b6 The field under validation must be missing or empty unless the other specified field equals a certain value. prohibited_unless:other,value prohibited_with \u00b6 The field under validation must be missing or empty only if any of the other specified fields are present. prohibited_with:field1,field2,... regex \u00b6 The field under validation must match the given regular expression. Internally, this rule uses the Python re.fullmatch() function. regex:pattern Note: When using the regex rule, it may be necessary to specify rules in a list instead of using pipe delimiters, especially if the regular expression contains a pipe character, like so: rules = { \"some_field\" : [ \"required\" , \"regex:a|b\" ] } required \u00b6 The field under validation must be present in the input data and not empty. A field is considered \"empty\" if one of the following conditions are true: The value is None . The value is an empty string. The value is an empty list. The value is an empty dict. required required_if \u00b6 The field under validation must be present and not empty if the other specified field equals a certain value. required_if:other,value required_unless \u00b6 The field under validation must be present and not empty unless the other specified field equals a certain value. required_unless:other,value required_with \u00b6 The field under validation must be present and not empty only if any of the other specified fields are present. required_with:field1,field2,... required_without \u00b6 The field under validation must be present and not empty only when any of the other specified fields are not present. required_without:field1,field2,... size \u00b6 The field under validation must have a size matching the given value. For strings, value corresponds to the number of characters. For integers, value corresponds to a given integer value. For floats, value corresponds to a given float value. For decimals, value corresponds to a given decimal value. For lists and dicts, value corresponds to the length of the list/dict. size:value starts_with \u00b6 The field under validation must start with one of the given values. starts_with:value,other,... string \u00b6 The field under validation must be a string. string url \u00b6 The field under validation must be a valid URL. url uuid4 \u00b6 The field under validation must be a valid uuid (version 4). uuid4","title":"Available Rules"},{"location":"usage/available_rules/#available-rules","text":"","title":"Available Rules"},{"location":"usage/available_rules/#accepted","text":"The field under validation must be yes, on, 1, or true. This is useful for validating \"Terms of Service\" acceptance. accepted","title":"accepted"},{"location":"usage/available_rules/#after","text":"The field under validation must be a value after a given date/time. For more details about formatting see the date_time rule. after:2019-12-31 12:00:00 If the after rule is accompanied by the date_time rule, and a non default format is specified, the specified format will be assumed for the after rule as well: date_time:%H:%M:%S|after:12:00:00 Instead of passing a date/time string to be evaluated by the strptime Python function, you may specify another field to compare against the date/time: after:some_field","title":"after"},{"location":"usage/available_rules/#after_or_equal","text":"The field under validation must be a value after or equal to a given date/time. For more information, see the after rule.","title":"after_or_equal"},{"location":"usage/available_rules/#alpha_num","text":"The field under validation must be entirely alpha-numeric characters. alpha_num","title":"alpha_num"},{"location":"usage/available_rules/#alpha_num_space","text":"The field under validation may have alpha-numeric characters, as well as spaces. alpha_num_space","title":"alpha_num_space"},{"location":"usage/available_rules/#before","text":"The field under validation must be a value before a given date/time. For more details about formatting see the date_time rule. before:2019-12-31 12:00:00 If the before rule is accompanied by the date_time rule, and a non default format is specified, the specified format will be assumed for the before rule as well: date_time:%H:%M:%S|before:12:00:00 Instead of passing a date/time string to be evaluated by the strptime Python function, you may specify another field to compare against the date/time: before:some_field","title":"before"},{"location":"usage/available_rules/#before_or_equal","text":"The field under validation must be a value before or equal to a given date/time. For more information, see the before rule.","title":"before_or_equal"},{"location":"usage/available_rules/#boolean","text":"The field under validation must be a boolean. boolean","title":"boolean"},{"location":"usage/available_rules/#date_time","text":"The field under validation must be a valid date/time matching the \"YYYY-MM-DD hh:mm:ss\" format, or a custom specified format. For example, a field being validated with the following format \"date_time:%m/%d/%Y\" must match the \"MM/DD/YYYY\" format. The date/time validation uses the strptime Python function. For more info on valid formatting symbols check the following Python docs . date_time date_time:format","title":"date_time"},{"location":"usage/available_rules/#decimal","text":"The field under validation must be a decimal. decimal","title":"decimal"},{"location":"usage/available_rules/#dict","text":"The field under validation must be a dict. dict","title":"dict"},{"location":"usage/available_rules/#email","text":"The field under validation must be a valid email address. email","title":"email"},{"location":"usage/available_rules/#ends_with","text":"The field under validation must end with one of the given values. ends_with:value,other,...","title":"ends_with"},{"location":"usage/available_rules/#filled","text":"The field under validation must not be empty when it is present. filled","title":"filled"},{"location":"usage/available_rules/#float","text":"The field under validation must be a float. float","title":"float"},{"location":"usage/available_rules/#in","text":"The field under validation must be included in the given list of values. in:value,other,...","title":"in"},{"location":"usage/available_rules/#integer","text":"The field under validation must be an integer. integer Note: Since version 2.0, True and False are considered valid integers, because bool is an instance of int in Python.","title":"integer"},{"location":"usage/available_rules/#ip","text":"The field under validation must be an IP address. ip","title":"ip"},{"location":"usage/available_rules/#json","text":"The field under validation must be a valid JSON string. json","title":"json"},{"location":"usage/available_rules/#list","text":"The field under validation must be a list. list","title":"list"},{"location":"usage/available_rules/#max","text":"The field under validation must be less than or equal to the given maximum value. For strings, value corresponds to the number of characters. For integers, value corresponds to a given integer value. For floats, value corresponds to a given float value. For decimals, value corresponds to a given decimal value. For lists and dicts, value corresponds to the length of the list/dict. max:value","title":"max"},{"location":"usage/available_rules/#min","text":"The field under validation must be greater than or equal to the given minimum value. For strings, value corresponds to the number of characters. For integers, value corresponds to a given integer value. For floats, value corresponds to a given float value. For decimals, value corresponds to a given decimal value. For lists and dicts, value corresponds to the length of the list/dict. min:value","title":"min"},{"location":"usage/available_rules/#not_with","text":"The field under validation can't be present if the other specified field is present. not_with:other","title":"not_with"},{"location":"usage/available_rules/#prohibited","text":"The field under validation must be missing or empty. A field is considered \"empty\" if one of the following conditions are true: The value is None . The value is an empty string. The value is an empty list. The value is an empty dict. prohibited","title":"prohibited"},{"location":"usage/available_rules/#prohibited_if","text":"The field under validation must be missing or empty if the other specified field equals a certain value. prohibited_if:other,value","title":"prohibited_if"},{"location":"usage/available_rules/#prohibited_unless","text":"The field under validation must be missing or empty unless the other specified field equals a certain value. prohibited_unless:other,value","title":"prohibited_unless"},{"location":"usage/available_rules/#prohibited_with","text":"The field under validation must be missing or empty only if any of the other specified fields are present. prohibited_with:field1,field2,...","title":"prohibited_with"},{"location":"usage/available_rules/#regex","text":"The field under validation must match the given regular expression. Internally, this rule uses the Python re.fullmatch() function. regex:pattern Note: When using the regex rule, it may be necessary to specify rules in a list instead of using pipe delimiters, especially if the regular expression contains a pipe character, like so: rules = { \"some_field\" : [ \"required\" , \"regex:a|b\" ] }","title":"regex"},{"location":"usage/available_rules/#required","text":"The field under validation must be present in the input data and not empty. A field is considered \"empty\" if one of the following conditions are true: The value is None . The value is an empty string. The value is an empty list. The value is an empty dict. required","title":"required"},{"location":"usage/available_rules/#required_if","text":"The field under validation must be present and not empty if the other specified field equals a certain value. required_if:other,value","title":"required_if"},{"location":"usage/available_rules/#required_unless","text":"The field under validation must be present and not empty unless the other specified field equals a certain value. required_unless:other,value","title":"required_unless"},{"location":"usage/available_rules/#required_with","text":"The field under validation must be present and not empty only if any of the other specified fields are present. required_with:field1,field2,...","title":"required_with"},{"location":"usage/available_rules/#required_without","text":"The field under validation must be present and not empty only when any of the other specified fields are not present. required_without:field1,field2,...","title":"required_without"},{"location":"usage/available_rules/#size","text":"The field under validation must have a size matching the given value. For strings, value corresponds to the number of characters. For integers, value corresponds to a given integer value. For floats, value corresponds to a given float value. For decimals, value corresponds to a given decimal value. For lists and dicts, value corresponds to the length of the list/dict. size:value","title":"size"},{"location":"usage/available_rules/#starts_with","text":"The field under validation must start with one of the given values. starts_with:value,other,...","title":"starts_with"},{"location":"usage/available_rules/#string","text":"The field under validation must be a string. string","title":"string"},{"location":"usage/available_rules/#url","text":"The field under validation must be a valid URL. url","title":"url"},{"location":"usage/available_rules/#uuid4","text":"The field under validation must be a valid uuid (version 4). uuid4","title":"uuid4"},{"location":"usage/custom_errors/","text":"Custom Errors \u00b6 If needed, you can specify custom error messages to overwrite the default error messages. Messages \u00b6 You can overwrite all messages for a specific rule. In the example below we are overwriting all 'required' error messages: validator . overwrite_messages = { \"required\" : \"Hey! This is a required field!\" } You can overwrite all messages for a specific field. In the example below we are overwriting all the error messages for the 'first_name' field: validator . overwrite_messages = { \"first_name\" : \"Hey! This field contains an error!\" } You can overwrite an error message for a specific rule of a specific field. In the example below we are overwriting the 'first_name.required' error message: validator . overwrite_messages = { \"first_name.required\" : \"Hey! This is a required field!\" } Fields \u00b6 If you would like the 'field' portion of your validation message to be replaced with a custom field name, you may do so like this: validator . overwrite_fields = { \"email\" : \"e-mail address\" } Values \u00b6 Sometimes you may need the 'value' portion of your validation message to be replaced with a custom representation of the value. For example, consider the following rule that specifies that a credit card number is required if the payment_type has a value of cc: rules = { \"credit_card_number\" : \"required_if:payment_type,cc\" } If this validation rule fails, it will produce the following error message: The credit_card_number field is required if the payment_type field equals cc. Instead of displaying cc as the payment type value, you may specify a custom value: validator . overwrite_values = { \"cc\" : \"credit card\" } Now if the validation rule fails it will produce the following message: The credit_card_number field is required if the payment_type field equals credit card.","title":"Custom Errors"},{"location":"usage/custom_errors/#custom-errors","text":"If needed, you can specify custom error messages to overwrite the default error messages.","title":"Custom Errors"},{"location":"usage/custom_errors/#messages","text":"You can overwrite all messages for a specific rule. In the example below we are overwriting all 'required' error messages: validator . overwrite_messages = { \"required\" : \"Hey! This is a required field!\" } You can overwrite all messages for a specific field. In the example below we are overwriting all the error messages for the 'first_name' field: validator . overwrite_messages = { \"first_name\" : \"Hey! This field contains an error!\" } You can overwrite an error message for a specific rule of a specific field. In the example below we are overwriting the 'first_name.required' error message: validator . overwrite_messages = { \"first_name.required\" : \"Hey! This is a required field!\" }","title":"Messages"},{"location":"usage/custom_errors/#fields","text":"If you would like the 'field' portion of your validation message to be replaced with a custom field name, you may do so like this: validator . overwrite_fields = { \"email\" : \"e-mail address\" }","title":"Fields"},{"location":"usage/custom_errors/#values","text":"Sometimes you may need the 'value' portion of your validation message to be replaced with a custom representation of the value. For example, consider the following rule that specifies that a credit card number is required if the payment_type has a value of cc: rules = { \"credit_card_number\" : \"required_if:payment_type,cc\" } If this validation rule fails, it will produce the following error message: The credit_card_number field is required if the payment_type field equals cc. Instead of displaying cc as the payment type value, you may specify a custom value: validator . overwrite_values = { \"cc\" : \"credit card\" } Now if the validation rule fails it will produce the following message: The credit_card_number field is required if the payment_type field equals credit card.","title":"Values"},{"location":"usage/custom_rules/","text":"Custom Rules \u00b6 Spotlight provides a variety of helpful validation rules; however, you may wish to specify some of your own. Tip Instead of creating a custom rule, you can also use a function as a rule . Both functions as a rule and custom rules provide great reusability. Functions offer more simplicity, but lack support for the use of rule parameters. Specifications \u00b6 To create a custom rule, create a class that inherits from the Rule class. A rule is required to have the following specifications: A rule should have a name attribute. A rule should implement the passes() method which contains the logic that determines if a value passes the rule. A rule should have a message property. Example \u00b6 Here is an example of an uppercase rule: from spotlight import Rule class UppercaseRule ( Rule ): \"\"\"Uppercase\"\"\" name = \"uppercase\" def passes ( self , field : str , value : Any , parameters : List [ str ], validator ) -> bool : self . message_fields = dict ( field = field ) return value . upper () == value @property def message ( self ) -> str : return \"The {field} field must be uppercase.\" As shown in the example above, the passes() method will receive the following arguments: field -- name of the field under validation value -- value of the field under validation parameters -- list of rule parameters validator -- instance of the validator After creating a custom rule it has to be registered with the validator: from custom_rules import UppercaseRule validator = Validator () validator . register_rule ( UppercaseRule ()) After registering the rule, it can be used: rules = { \"test\" : \"uppercase\" } data = { \"test\" : \"HELLO WORLD!\" } Attributes \u00b6 In addition to the name attribute, a rule has 2 additional attributes which are set to False by default: implicit & stop . These attributes may be overwritten. Implicit \u00b6 Setting implicit to True will cause the field under validation to be validated against the rule even if the field is not present. This is useful for rules such as required . Stop \u00b6 Setting stop to True causes the validator to stop validating the rest of the rules specified for the current field if the current rule fails. Message Fields \u00b6 If a rule contains a message property that contains keyword arguments (words surrounded by curly braces) like the one in the example below, the message_fields variable needs to be set in the passes method. @property def message ( self ) -> str : return \"The {field} field must be uppercase.\" The message_fields variable can be set as shown in the example below. The keyword arguments in the message property will be replaced with the values from the message_fields dictionary. def passes ( self , field : str , value : Any , parameters : List [ str ], validator ) -> bool : self . message_fields = dict ( field = field )","title":"Custom Rules"},{"location":"usage/custom_rules/#custom-rules","text":"Spotlight provides a variety of helpful validation rules; however, you may wish to specify some of your own. Tip Instead of creating a custom rule, you can also use a function as a rule . Both functions as a rule and custom rules provide great reusability. Functions offer more simplicity, but lack support for the use of rule parameters.","title":"Custom Rules"},{"location":"usage/custom_rules/#specifications","text":"To create a custom rule, create a class that inherits from the Rule class. A rule is required to have the following specifications: A rule should have a name attribute. A rule should implement the passes() method which contains the logic that determines if a value passes the rule. A rule should have a message property.","title":"Specifications"},{"location":"usage/custom_rules/#example","text":"Here is an example of an uppercase rule: from spotlight import Rule class UppercaseRule ( Rule ): \"\"\"Uppercase\"\"\" name = \"uppercase\" def passes ( self , field : str , value : Any , parameters : List [ str ], validator ) -> bool : self . message_fields = dict ( field = field ) return value . upper () == value @property def message ( self ) -> str : return \"The {field} field must be uppercase.\" As shown in the example above, the passes() method will receive the following arguments: field -- name of the field under validation value -- value of the field under validation parameters -- list of rule parameters validator -- instance of the validator After creating a custom rule it has to be registered with the validator: from custom_rules import UppercaseRule validator = Validator () validator . register_rule ( UppercaseRule ()) After registering the rule, it can be used: rules = { \"test\" : \"uppercase\" } data = { \"test\" : \"HELLO WORLD!\" }","title":"Example"},{"location":"usage/custom_rules/#attributes","text":"In addition to the name attribute, a rule has 2 additional attributes which are set to False by default: implicit & stop . These attributes may be overwritten.","title":"Attributes"},{"location":"usage/custom_rules/#implicit","text":"Setting implicit to True will cause the field under validation to be validated against the rule even if the field is not present. This is useful for rules such as required .","title":"Implicit"},{"location":"usage/custom_rules/#stop","text":"Setting stop to True causes the validator to stop validating the rest of the rules specified for the current field if the current rule fails.","title":"Stop"},{"location":"usage/custom_rules/#message-fields","text":"If a rule contains a message property that contains keyword arguments (words surrounded by curly braces) like the one in the example below, the message_fields variable needs to be set in the passes method. @property def message ( self ) -> str : return \"The {field} field must be uppercase.\" The message_fields variable can be set as shown in the example below. The keyword arguments in the message property will be replaced with the values from the message_fields dictionary. def passes ( self , field : str , value : Any , parameters : List [ str ], validator ) -> bool : self . message_fields = dict ( field = field )","title":"Message Fields"},{"location":"usage/rules/","text":"Rules \u00b6 Definition \u00b6 Validation rules can be defined in multiple ways. String Notation \u00b6 You can write rules as single pipe delimited strings: rules = { \"id\" : \"required|integer\" , \"email\" : \"required|email\" , \"first_name\" : \"required|string\" , \"last_name\" : \"required|string\" , \"password\" : \"required|min:8|max:255\" , } List Notation \u00b6 Alternatively to the string notation, rules can be specified as lists of rules: rules = { \"id\" : [ \"required\" , \"integer\" ], \"email\" : [ \"required\" , \"email\" ], \"first_name\" : [ \"required\" , \"string\" ], \"last_name\" : [ \"required\" , \"string\" ], \"password\" : [ \"required\" , \"min:8\" , \"max:255\" ], } Function as a Rule \u00b6 If you require some more custom or complex validation logic than what is provided by the available rules, but you don't want to create a custom rule , you can use a lambda expression or a function as a rule. The expression or function is expected to return a string if the validation fails, or None if it passes. The returned string is your custom error message. Note You can only use a function as a rule when using the list notation . Tip Python functions return None by default, so in most cases you probably don't want to explicitly return None . Examples \u00b6 An example using a lambda expression: rules = { \"some_field\" : [ \"required\" , \"integer\" , lambda field , value , validator : f \"The { field } field has to be greater than 2.\" if value <= 2 else None , ], } An example using a function: def custom_validate ( field , value , validator ): if value <= 2 : return f \"The { field } field has to be greater than 2.\" rules = { \"some_field\" : [ \"required\" , \"integer\" , custom_validate ], } Tip Just like custom rules , if needed, you can add implicit and stop flags to your rule function: def custom_validate ( value , ** kwargs ): if not value : return \"Value is required!\" custom_validate . implicit = True custom_validate . stop = True Provided Arguments \u00b6 Both lambda expressions and functions will have access to the following keyword arguments: field -- name of the field under validation value -- value of the field under validation validator -- instance of the validator Tip If you only need value in your function or expression, you can use **kwargs to omit the rest: def custom_validate ( value , ** kwargs ): if value <= 2 : return \"Value has to be greater than 2.\"","title":"Rules"},{"location":"usage/rules/#rules","text":"","title":"Rules"},{"location":"usage/rules/#definition","text":"Validation rules can be defined in multiple ways.","title":"Definition"},{"location":"usage/rules/#string-notation","text":"You can write rules as single pipe delimited strings: rules = { \"id\" : \"required|integer\" , \"email\" : \"required|email\" , \"first_name\" : \"required|string\" , \"last_name\" : \"required|string\" , \"password\" : \"required|min:8|max:255\" , }","title":"String Notation"},{"location":"usage/rules/#list-notation","text":"Alternatively to the string notation, rules can be specified as lists of rules: rules = { \"id\" : [ \"required\" , \"integer\" ], \"email\" : [ \"required\" , \"email\" ], \"first_name\" : [ \"required\" , \"string\" ], \"last_name\" : [ \"required\" , \"string\" ], \"password\" : [ \"required\" , \"min:8\" , \"max:255\" ], }","title":"List Notation"},{"location":"usage/rules/#function-as-a-rule","text":"If you require some more custom or complex validation logic than what is provided by the available rules, but you don't want to create a custom rule , you can use a lambda expression or a function as a rule. The expression or function is expected to return a string if the validation fails, or None if it passes. The returned string is your custom error message. Note You can only use a function as a rule when using the list notation . Tip Python functions return None by default, so in most cases you probably don't want to explicitly return None .","title":"Function as a Rule"},{"location":"usage/rules/#examples","text":"An example using a lambda expression: rules = { \"some_field\" : [ \"required\" , \"integer\" , lambda field , value , validator : f \"The { field } field has to be greater than 2.\" if value <= 2 else None , ], } An example using a function: def custom_validate ( field , value , validator ): if value <= 2 : return f \"The { field } field has to be greater than 2.\" rules = { \"some_field\" : [ \"required\" , \"integer\" , custom_validate ], } Tip Just like custom rules , if needed, you can add implicit and stop flags to your rule function: def custom_validate ( value , ** kwargs ): if not value : return \"Value is required!\" custom_validate . implicit = True custom_validate . stop = True","title":"Examples"},{"location":"usage/rules/#provided-arguments","text":"Both lambda expressions and functions will have access to the following keyword arguments: field -- name of the field under validation value -- value of the field under validation validator -- instance of the validator Tip If you only need value in your function or expression, you can use **kwargs to omit the rest: def custom_validate ( value , ** kwargs ): if value <= 2 : return \"Value has to be greater than 2.\"","title":"Provided Arguments"},{"location":"usage/validator/","text":"Validator \u00b6 Nested Validation \u00b6 rules = { \"token\" : \"required|string\" , \"person.first_name\" : \"required|string|max:255\" , \"person.last_name\" : \"required|string|max:255\" , \"person.email\" : \"required|email\" , \"person.password\" : \"required|min:8|max:255\" } data = { \"token\" : \"test-token\" , \"person\" : { \"first_name\" : \"John\" , \"last_name\" : \"Doe\" , \"email\" : \"john.doe@example.com\" , \"password\" : \"test1234\" } } validator = Validator () errors = validator . validate ( data , rules ) List Validation \u00b6 rules = { \"players\" : \"required|list|min:2\" , \"players.*.username\" : \"required\" } data = { \"players\" : [ { \"username\" : \"Player 1\" }, { \"username\" : \"Player 2\" } ] } validator = Validator () errors = validator . validate ( data , rules ) Direct Validation \u00b6 Sometimes there is a need for quick and simple validation, without having to create a rule set. The Validator class exposes several static methods that can be used for direct validation. For example: validator = Validator () email = \"john.doe@example.com\" if validator . valid_email ( email ): print ( \"This is a valid email!\" ) Or like this: if Validator . valid_email ( email ): print ( \"This is a valid email!\" ) Available methods: valid_alpha_num valid_alpha_num_space valid_boolean valid_date_time valid_decimal valid_dict valid_email valid_float valid_integer valid_ip valid_json valid_list valid_string valid_url valid_uuid4","title":"Validator"},{"location":"usage/validator/#validator","text":"","title":"Validator"},{"location":"usage/validator/#nested-validation","text":"rules = { \"token\" : \"required|string\" , \"person.first_name\" : \"required|string|max:255\" , \"person.last_name\" : \"required|string|max:255\" , \"person.email\" : \"required|email\" , \"person.password\" : \"required|min:8|max:255\" } data = { \"token\" : \"test-token\" , \"person\" : { \"first_name\" : \"John\" , \"last_name\" : \"Doe\" , \"email\" : \"john.doe@example.com\" , \"password\" : \"test1234\" } } validator = Validator () errors = validator . validate ( data , rules )","title":"Nested Validation"},{"location":"usage/validator/#list-validation","text":"rules = { \"players\" : \"required|list|min:2\" , \"players.*.username\" : \"required\" } data = { \"players\" : [ { \"username\" : \"Player 1\" }, { \"username\" : \"Player 2\" } ] } validator = Validator () errors = validator . validate ( data , rules )","title":"List Validation"},{"location":"usage/validator/#direct-validation","text":"Sometimes there is a need for quick and simple validation, without having to create a rule set. The Validator class exposes several static methods that can be used for direct validation. For example: validator = Validator () email = \"john.doe@example.com\" if validator . valid_email ( email ): print ( \"This is a valid email!\" ) Or like this: if Validator . valid_email ( email ): print ( \"This is a valid email!\" ) Available methods: valid_alpha_num valid_alpha_num_space valid_boolean valid_date_time valid_decimal valid_dict valid_email valid_float valid_integer valid_ip valid_json valid_list valid_string valid_url valid_uuid4","title":"Direct Validation"}]}